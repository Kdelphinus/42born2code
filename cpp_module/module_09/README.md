# CPP Module 09

## Index

- [Subject](#subject)
    - [Module-specific rules](#module-specific-rules)
    - [ex00](#ex00)
    - [ex01](#ex01)
    - [ex02](#ex02)
- [주의할 점](#주의할-점)
- [References](#references)

## Subject

### Module-specific rules

- 이 모듈에선 반드시 표준 컨테이너를 사용해야 한다.
- 한 번 사용한 컨테이너는 다른 문제에서 사용할 수 없다.

> 문제를 풀기 전에 subject 전체를 읽는 것이 좋다.

> 두 개의 컨테이너를 사용해야 하는 ex02를 제외하고 각 문제마다 적어도 한 개의 컨테이너를 사용해야 한다.

- 소스 파일을 컴파일 할 때, `-Wall -Wextra -Werror` 플래그를 사용해야 한다.
- 반드시 `c++` 을 사용해야 하며 relink 되어서는 안 된다.
- Makefile에는 적어도 $(NAME), all, clean, fclean, re 규칙이 있어야 한다.

### ex00

- files: Makefile, main.cpp, BitcoinExchange.{cpp, hpp}

- 특정 날짜에 특정 비트코인의 가치를 출력하는 프로그램 만들기
- 이 프로그램은 csv 형식의 데이터베이스를 사용해야 하며, 데이터베이스는 subject와 함께 제공된다.
- 이 프로그램은 평가할 가격/날짜가 저장된 또 다른 데이터베이스를 받는다.
- 이 프로그램은 아래와 같은 규칙을 지켜야 한다.
    - 이 프로그램 이름은 `btc` 이다.
    - 이 프로그램은 반드시 파일을 인자로 받아야 한다.
    - 인자로 받는 파일의 각 줄은 반드시 **data | value** 형태로 되어있어야 한다.
    - 날짜는 **Year-Month-Day** 형태로 되어있어야 한다.
    - 유효한 값은 0과 1000 사이에 소수와 양의 정수이다.

> 이 연습문제의 유효성을 확인하려면 코드에 하나 이상의 컨테이너를 사용해야 한다.
> 또한 가능한 오류를 적절한 오류 메세지로 처리해야 한다.

- 아래는 `input.txt` 파일의 예시이다.

```txt
data | value
2011-01-03 | 3
2011-01-03 | 2
2011-01-03 | 1
2011-01-03 | 1.2
2011-01-09 | 1
2012-01-11 | -1
2001-42-42
2012-01-11 | 1
2012-01-11 | 2147483648
```

- 이 프로그램은 input 파일 안에 있는 값을 사용해야 한다.
- 표준 출력에는 데이터베이스에 표시된 날짜에 따라 값에 환율을 곱한 결과가 표시되어야 한다.

> input 에 사용된 날짜가 데이터베이스에 존재하지 않는 경우, 데이터베이스에 포함된 가장 가까운 날짜를 사용해야 한다.
> 미래가 아니라 과거 날짜를 사용해야 한다.

- 아래는 프로그램 출력 예시이다.

```shell
$> ./btc
Error: could not open file.
$> ./btc input.txt
2011-01-03 => 3 = 0.9
2011-01-03 => 2 = 0.6
2011-01-03 => 1 = 0.3
2011-01-03 => 1.2 = 0.36
2011-01-09 => 1 = 0.32
Error: not a positive number.
Error: bad input => 2001-42-42
2012-01-11 => 1 = 7.1
Error: too large a number.
```

> **경고** : 이 연습은 검증하는 데 사용하는 컨테이너는 이 모듈의 나머지 부분에서는 더 이상 사용할 수 없다.

### ex01

- files: Makefile, main.cpp, RPN.{cpp, hpp}

- 이 프로그램은 아래와 같은 조건을 만족해야 한다.
    - 이 프로그램 이름은 `RPN` 이다.
    - 이 프로그램은 폴란드어 수학식을 인수로 사용해야 한다.
    - 이 연산에서 사용되고 인수로 전달되는 숫자는 항상 10보다 작다. 물론 계산 중 값과 결과는 이 규칙을 고려하지 않는다.
    - 프로그램에서 이 식을 처리하고 표준 출력에 정확한 결과를 출력해야 한다.
    - 프로그램을 실행하는 동안 오류가 발생하면 표준 출력에 오류 메세지가 표시되어야 한다.
    - 프로그램에서 "+-/*" 토큰으로 작업을 처리할 수 있어야 한다.

> 이 연습의 유효성을 확인하려면 코드에 하나 이상의 컨테이너를 사용해야 한다.

> 대괄호나 십진수를 관리할 필요는 없다.

- 아래는 프로그램 출력 예시이다.

```shell
$> ./RPN "8 9 * 9 - 9 - 9 - 4 - 1 +"
42
$> ./RPN "7 7 * 7 -"
42
$> ./RPN "1 2 * 2 / 2 * 2 4 - +"
0
$> ./RPN "(1 + 1)"
Error
```

> **경고** : 이전에 사용한 컨테이너는 여기서 사용이 불가하다. 컨테이너들은 이전에 사용하지 않은 것들만 유효하다.

### ex02

- file: Makefile, main.cpp, PmergeMe.{cpp, hpp}

아래와 같은 제약 조건을 가진 프로그램을 만들어야 한다.

- 프로그램의 이름은 `PmergeMe` 으로 만들어야 한다.
- 프로그램의 인수로 양의 정수 시퀀스를 사용할 수 있어야 한다.
- 프로그램에서 양의 정수 시퀀를 정렬하려면 **병합-삽입 정렬 알고리즘** 을 사용해야 한다.

> 명확하게 하기 위해서는 **포드-존슨 알고리즘** 을 사용해야 한다.

- 프로그램 실행 중 오류가 발생하면 표준 출력에 오류 메세지가 표시되어야 한다.

> 이 연습의 유효성을 확인하려면 코드에 두 개 이상의 컨테이너를 사용해야 한다.
> 또한 프로그램에서 3000개 이상의 다른 정수를 처리할 수 있어야 한다.

> 각 컨테이너에 대해 알고리즘을 구현하여 제네릭 함수를 사용하지 않는 것이 좋다.
> 이때, 제네릭 함수는 템플릿 함수와 동일한 의미다.

아래는 표준 출력에 한 줄씩 표시해야 하는 정보에 대한 몇 가지 추가 지침이다.

- 첫 번째 줄에는 명시적 텍스트가 표시된 다음, 정렬되지 않은 양의 정수 시퀀스가 표시되어야 한다.
- 두 번째 줄에는 명시적 텍스트와 함께 정렬된 양의 정수 시퀀스가 표시되어야 한다.
- 세 번째 줄에는 양의 정수 시퀀스를 정렬하는 데 사용되는 첫 번째 컨테이너를 지정하여 알고리즘이 사용한 시간을 명시적 텍스트로 표시해야 한다.
- 마지막 줄에는 양의 정수 시퀀스를 정렬하는 데 사용되는 두 번째 컨테이너를 지정하여 알고리즘이 사용한 시간을 나타내는 명시적 텍스트를 표시해야 한다.

> 정렬을 수행하는 데 사용된 시간을 표시하는 형식은 자유이지만, 선택한 정밀도를 통해 사용된 두 컨테이너 사이의 차이를 명확하게 알 수 있어야 한다.

예시는 아래와 같다.

```shell
$> ./PmergeMe 3 5 9 7 4
Before: 3 5 9 7 4
After: 3 4 5 7 9
Time to process a range of 5 elements with std::[..] : 0.00031 us
Time to process a range of 5 elements with std::[..] : 0.00014 us
$> ./PmergeMe `shuf -i 1-100000 -n 3000 | tr "\n" " "`
Before: 141 79 526 321 [...]
After: 79 141 321 526 [...]
Time to process a range of 3000 elements with std::[..] : 62.14389 us
Time to process a range of 3000 elements with std::[..] : 69.27212 us
$> ./PmergeMe "-1" "2"
Error
$> # For OSX USER:
$> ./PmergeMe `jot -r 3000 1 100000 | tr '\n' ' '`
[...]
```

> 예시에서 시간 표시가 일부러 이상하게 되어 있다.
> 물론 정렬 부분과 데이터 관리 부분 모두 모든 작업을 수행하는 데 사용된 시간을 표시해야 한다.

> 경고: 이전 연습에서 사용한 컨테이는 사용하면 안 된다.

> 중복과 관련된 오류의 관리는 사용자 재량에 맡긴다.

## Ford-Johnson algorithm 요약

1. 값을 2개씩 짝지어 pair의 배열로 묶는다.
    - 원소의 개수가 홀수라면 마지막 원소는 따로 둔다.
2. 각 pair의 큰 값을 기준으로 배열을 정렬한다.
    - pair 정렬 과정에서도 merge-insertion 정렬을 쓰는 것이 이상적이다.
3. 정렬된 pair 배열에서 큰 값과 작은 값을 다른 배열에 담아둔다.
4. 큰 값을 담아둔 배열에서 작은 값을 담은 배열의 원소를 구한 순서(레퍼런스 참고)대로 하나씩 탐색해서 담는다.
    - 1 - 3 - 2 - 5 - 4 - 11 - 10 - 9 - 8 - 7 - 6 - 21 - 20 - ...
5. 원소의 개수가 홀수일 때, 따로 저장해둔 마지막 원소를 이진탐색하여 삽입한다.

## 주의할 점

## References

- [42Seoul, cpp module 09](./en.subject.pdf)
- [팔만코딩경, cpp09 - mergeInsertionSort(ford-johnson algorithm)](https://80000coding.oopy.io/6880ebc0-acb3-4225-809f-37fc419adf71)