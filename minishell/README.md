# minishell

## 1. git 관련

- 별일 없으면 **무조건 한 파일씩!** commit 하기
- log 메세지는 다음과 같이 할 것
```shell
{변경한 파일 이름} | {변경한 내용}
```

- push하면 바로 slack으로 알려주기
- slack보고 먼저 pull하는거 잊지 말기
- 만약 충돌하면 slack

## 2. 팀

|팀이름|구성원|할 일|
|:---|:---|:---|
|파싱|재권, 주영|- 자료구조에 바로 넣는 토큰화|
|실행|규선, 명준, 수빈|- 명령어 실행|


## 3. 일정

- 매 주, 금요일 정기 스터디
- 일정표

|일정|할 일|
|:---|:---|
|3/24~25| - 팀 정하기<br>- shell docu 읽기|
|3/27~4/1|**파싱 파트**<br>- 넘길 자료구조 정의<br>- 토큰화<br><br>**실행 파트**<br>- bulit-in 함수 만들기<br>- redirection 구현<br>   - hear doc 예의주시|
|4/3~8|**파싱 파트**<br>- 토큰화<br><br>**실행 파트**<br>- 다중 파이프 구현<br><br>**공통**<br>- 예외 처리|
|4/10~15|**파싱 파트**<br>- 토큰화<br><br>**실행 파트**<br>- 다중 파이프 구현|
|4/17~22|**공통**<br>-4/17에 평가 받기<br>- 통과 시, 다음 과제<br>- 실패 시, 피드백 후 리트라이|

## 4. 진행 현황

### 1) 2023.03.30
- redirection 설정 구현
	- 여러 개일 때, 우선순위 찾기
- export 체크
	- += 기능 구현
	- 가능한 이름 체크 구현
		- 시작 문자: [a-z], [A-Z], _ 만 가능
		- 그 외 문자: [a-z], [A-Z], _, [0-9] 만 가능

### 2) 2023.03.31
- redirection의 동일한 기능이 여러 개 들어오면 가장 오른쪽에 입력된 파일 기준으로 실행
	- 그 외 파일들도 open 동작은 실행
- t_token 구조체에 맞춰서 구현하기
- built-in은 파이프 안에 있을 때만 fork 실행
- execute 수도 코드
```c
execute
{
	STDIN, STDOUT 복사;
	if (pipe_cnt == 0)
	{
		redirection 설정;
		built-in or extern func 함수 실행;
	}
	else
	{
		다중 파이프 구현
	}
	STDIN, STDOUT 복구;
}
```

### 3) 다중 파이프 관련 개념 정립(2023.04.03)

```shell
A | B | C | D | E
```

- 파이프는 순서대로 1~4번 파이프로 부른다.
- 각각의 파트(A~E)는 fork 후, 자식 프로세스에서 실행된다.
- pipe() 함수는 파이프 앞 직전 파트가 실행되기 전에 실행된다.
- fd 배열은 이중배열로 정의하며 int * 배열은 파이프 개수대로, 그 안에 배열은 2칸으로 할당된다.

위와 같은 규칙을 정하면 각 파트에서 입출력은 다음과 같이 정의된다.

```
STDIN    -> A -> fd[0][1]
fd[0][0] -> B -> fd[1][1]
fd[1][0] -> C -> fd[2][1]
fd[2][0] -> D -> fd[3][1]
fd[3][0] -> E -> STDOUT
```

따라서 각 파트에서 필요한 fd는 두 개다. 그러나 파이프를 실행할 때, 출력과 맞는 입력이 한 쌍으로 생성되기에 열려있어야 하는 fd는 총 3개다.

{이전 파이프의 입력} -> 현재 파트 -> {현재 파트 직전에 실행한 파이프의 출력}

자식이 dup2를 통해 파이프를 위와 같이 바꿀 동안 부모는 더이상 쓰지 않을 fd를 잘 close해주어야 한다. 이를 수도코드로 나타내면 다음과 같다.

```c
int fd[4][2]; // 지금은 파이프 개수를 아니까 편의를 위해 정적 할당
pid_t pid;

pipe(fd[0]);
pid = fork();
if (pid == 0)
	A 파트에 맞게 dup2;
else
	close(fd[0][1]);

pipe(fd[1]);
pid = fork();
if (pid ==0)
	B 파트에 맞게 dup2;
else
{
	close(fd[0][0]);
	close(fd[1][1]);
}
pipe(fd[2]);
pid = fork();
if (pid ==0)
	C 파트에 맞게 dup2;
else
{
	close(fd[1][0]);
	close(fd[2][1]);
}
pipe(fd[3]);
pid = fork();
if (pid ==0)
	D 파트에 맞게 dup2;
else
{
	close(fd[2][0]);
	close(fd[3][1]);
}
pipe(fd[4]);
pid = fork();
if (pid ==0)
	E 파트에 맞게 dup2;
else
	close(fd[3][0]);
```

처음과 마지막 파트는 별도 처리가 필요하고 중간 파트들은 while로 처리할 수 있다.

### 4) 2023.04.07 ~ 08
- 파싱 파트 처리한 것
	- export a='algo"algo' 실행 처리
	- 환경변수 치환 처리 
		- $ABC/{file namd} 란 입력어가 주어질 때, $ABC 변수에 실제 경로가 있다면 실행되야 함
	- syntax error
	- <<, >>의 처리 중, 명령어가 제대로 저장되지 않는 상태 수정
	- "", '' 등의 빈문자열이 입력으로 들어올 때, arg가 할당되도록 수정
	- "" 안에 들어오는 인자 중에 # 뒤에 주석 처리되는 현상 수정
	- "$USER d" 등의 환경변수와 혼합된 입력이 비정상적으로 출력되는 현상 수정
	- 입력된 것들을 무조건 소문자로 치환되는 현상 수정
- 실행 파트 처리한 것
	- exit 명령어 실행 시, 출력되는 "exit"의 fd를 STDERR로 결정
		- 출력되는 것이 어디에도 정의되어 있지 않음
		- redirection을 통해 검사했을 때, 2로 들어가는 것 확인
	- open() 함수 실행 시, fd error에 따른 동작 추가
		- infile이 없을 때
		- ./ 등의 입력어가 들어올 때
	- 경로만 입력했을 때, 폴더일 때 출력되는 에러메세지 수정
	- "./test", "/test", "test" 구분되도록 수정
	- 있는 파일을 그대로 입력했을 때, "command not found"가 나오도록 수정
	- unset 명령어의 인자로 변수 이름이 될 수 없는 것들이 들어올 때 에러 처리

#### 5) 2023.04.11
- here_doc 관련 close 이슈 확인
  - 구조체 변경 or while로 처리 예정
- here_doc에 환경변수 형태가 들어오면 대체 안하고 있음
- 키만 있는 환경변수를 변환할 때, NULL 참조

#### 6) 2023.04.14
- heredoc 중간에 ctrl+d가 입력될 때,tmp파일 정리하고 NULL 참조 안하도록 수정
- 프롬프트 상에서 ctrl+c가 입력될 때, ^C가 출력되는 현상 수정
- built-in 함수 실행 후, ctrl+c가 입력될 때, 종료되는 현상 수정
- 미니쉘 안에서 미니쉘을 여러번 실행한 후, ctrl+c 입력 시, 문제 발생 수정
- 자식을 위한 signal 구현 및 적용
- pipe 시그널 exit 수정
- echo "$a"s 명령어가 출력되지 않는 현상 수정
- heredoc 중간에 다른 터미널에서 heredoc을 실행하면 같은 파일 내에서 작업하는 현상 수정
- heredoc을 위한 임시 파일은 /tmp 폴더에 생성되도록 수정

#### 7) 2023.04.17
- heredoc 관련 signal 함수 구현 및 적용
- heredoc의 종결조건에 "", ''으로 묶이지 않는 환경변수는 입력시, 치환되어 기록되어야 함
- leak check
- norm check

#### 8) 2023.04.19
- _s 함수를 사용하도록 변경
- fork_s와 pipe_s 함수가 실패할 시, perror 출력 후 exit으로 종료되도록 수정
