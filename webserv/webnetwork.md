# 해치지 않는 웹 정리

## 1. 웹 동작 방식
레스토랑에 손님이 스테이크를 주문하는 경우, 주문을 받는 종업원과 요리를 만드는 요리사가 있다.
이를 웹에 빗대면 **종업원은 웹 클라이언트**, **요리사는 웹 서버**로 볼 수 있다.

두 프로그램은 주문을 잘 받고 알맞은 서비스를 제공하는 것이 목적이다.

![web client](/img/webclient.png)
### 웹 클라이언트(Web Client)

웹 클라이언트는 **사용자가 웹에 접근하는 프로그램**을 말한다.

그런데 대부분 우리가 육안으로 보는 웹은 웹 브라우저에서 실행되기에 일반적으로 Chrome 등 우리가 알고 있는 웹 브라우저들을 웹 클라이언트라고 말한다.
그래서 우리가 브라우저 주소창에 주소를 입력하면, 클라이언트는 사용자로부터 받은 URL에 대한 정보를 찾아 HTTP 메세지 형태로 서버에게 요청하는 것이다.

### 웹 서버(Web Server)
웹 서버는 **웹 페이지, 사이트 또는 앱을 저장하는 프로그램**을 말한다.

서버는 다음과 같은 동작을 수행한다.

1. 클라이언트에서 요청한 HTTP 메세지를 확인
2. 이에 맞는 데이터(HTML, CSS, JS, Image 등)를 처리
3. 다시 클라이언트에게 응답

대표적인 웹 서버의 종류는 아파치 웹 서버(Apache Web Server), GWS, IIS 등이 있다.

### WAS(Web Application Server)
여기서 다시 레스토랑으로 돌아오자. 만약 요리사가 여러 명이라면 요리들이 각각 요리사들에게 분배되어야 한다.
이 때 주문을 확인하고 **역할을 분배하는 것이 웹 서버**, **실제로 요리하는 요리사들이 WAS** 라고 볼 수 있다.

즉, 서버 혼자서 모든 로직을 수행하지 못하기에 이를 보조하는 역할을 WAS가 한다고 볼 수 있다.
WAS는 **웹 어플리케이션 서버라는 이름에서 알 수 있듯이 사용자 컴퓨터나 장치에 웹 어플리케이션을 수행해주는 미들웨어**를 말한다.
종류로는 아파치 톰캣(Apache Tomcat), 레진(Resin), 제이런(JRun) 등이 있다.

따라서 클라이언트에게 메세지를 받으면 다음과 같은 동작을 진행한다.

1. 웹 서버는 요청에 필요한 페이지의 로직이나 데이터베이스의 연동을 위해 WAS에 처리를 요청한다.
2. WAS는 요청을 받아와 동적인 페이지 처리를 담당하고 DB에 데이터 정보를 받아온다.
3. DB와 연동하여 데이터를 처리한 뒤, 생성한 파일을 다시 서버에게 반환한다.

WAS는 웹 서버의 할 일을 분배하고 서버의 부담을 줄이며 빠르게 동적 컨텐츠를 처리할 수 있도록 만든다.

### DB(Data Base)
데이터베이스는 **데이터의 정보를 저장하는 곳**이며 WAS에서 데이터를 요청하면 필요한 데이터를 전달한다.

만약 사용자가 블로그에 새로 포스팅을 올려서 그 내용을 서버에 저장해야한다고 하면, WAS에서 DB에게 해당 내용을 저장하도록 요청하고, 
DB는 내용을 정리하여 저장하는 것이다.

## 2. http 메세지
클라이언트는 서버에게 원하는 데이터를 요청하고, 요청하는 데이터에 대한 응답을 받고 나서야 HTML, CSS, Image 등 원하는 리소스를 받아볼 수 있다.
그리고 이렇게 클라이언트와 서버 간 소통을 가능케 하는 것이 **HTTP**이다.

### HTTP란
프로그램은 상호 약속을 통해 만들어진 어떤 규격을 가지고 메세지를 주고 받는데 이 때 사용하는 규약이 프로토콜이다.

HTTP(Hyper Text Transfer Protocol)는 **웹 브라우저와 웹 서버 간에 데이터를 주고받기 위해 사용하는 인터넷 프로토콜**이다.
프로토콜이란 상호 간에 정의한 규칙을 의미하며 특정 기기 간에 데이터를 주고 받기 위해 정의되었다.
이러한 프로토콜 중에서 인터넷에서 사용하며 HTML을 비롯한 다양한 리소스들을 전송할 수 있는 프로토콜이 HTTP이다.

### HTTP 메세지
요청하고 전송하는 과정에서 클라이언트와 서버는 각각 HTTP 메세지를 전송한다.

- 요청 메세지(Request Message): 클라이언트가 서버에 요청하는 메세지
- 응답 메세지(Response Message): 클라이언트의 요청을 해석한 서버가 응답하는 메세지

HTTP 메세지는 일정한 포맷이 존재하며 이러한 포맷은 누가 누구에게 보내는지에 따라 형식이 다르다.

### 요청 메세지(Request Message)
요청 메세지는 손님이 점원에게 요청한 정보가 담긴 주문서와 유사하다. **클라이언트가 서버에 요청하는 정보**가 담겨 있으며 아래와 같은 구조를 가진다.

![request message](/img/request_message.png)

#### 메서드(Method)
메서드는 **어떻게 처리하는지, 즉 처리 방식**에 대한 정보를 가진다.
다시 말해 클라이언트가 서버에게 데이터를 요청하고, 요청하는 데이터에 수행하고자 하는 동작을 나타낸다.

- GET: 존재하는 자원에 대한 요청
- POST: 새로운 자원을 생성
- PUT: 존재하는 자원에 대한 변경
- DELETE: 존재하는 자원에 대한 삭제

#### 경로(URL)
경로는 **메서드를 참고하여 수행할 대상, 즉 무엇을**에 해당한다. 주로 가져오려는 리소스의 경로를 표시하며 완전한 형식, 상대적 형식 등 메서드의 유형에 따라 다양한 포맷이 있다.

#### 프로토콜 버전(Version of the protocol)
HTTP 프로토콜의 버전을 표시한다. 현재(17년도)는 1.1버전과 보안성을 강화한 2버전이 주를 이룬다.

#### 헤더(Headers)
서버에 대한 추가 정보를 전달한다. 주로 호스트의 정보나 접속하고 있는 사용자의 정보, 열려고 하는 페이지의 정보 등을 확인할 수 있다.
예시에 나온 헤더 속성은 다음과 같다.

- uset-agent
  - 웹 브라우저의 다른 표현
  - 요청하는 웹 브라우저의 정보 및 운영체제를 표시한다.
- accept-encoding
  - 클라이언트가 이해할 수 있는 압축 방식을 표시
  - accept-encoding을 표기하여 서버에게 전송하면 서버는 필요한 경우 리소스를 압축하여 반환한다.

#### 공백 라인(Empty Line)
공백 라인은 **헤더와 본문을 구분하는 역할**을 한다.

#### 본문(Request Message Body)
메세지의 가장 마지막 컨텐츠이다. 그리고 다른 컨텐츠와 달리 필수가 아니다.
메서드가 `GET, HEAD, DELETE, OPTIONS` 처럼 리소스를 가져오는 요청에는 보통 본문이 필요없다.
따라서 `POST` 처럼 서버에 새로운 자원을 추가해야 하는 경우에만 그 정보를 본문에 작성하여 전달한다.

### 응답 메세지(Response Message)
응답 메세지는 **클라이언트의 요청에 대한 서버의 답변**이 담겨있다.

![response message](/img/response_message.png)

#### 프로토콜 버전(Version of the protocol)
요청 메세지와 동일하며 HTTP 프로토콜 버전을 나타낸다.

#### 상태 코드(Status code)
상태 코드는 **클라이언트 요청의 성공 여부를 숫자로 나타낸 것**이다.
상태 메세지는 **상태 코드를 이해하기 쉽게 영어로 풀어쓴 메세지**이다.

상태 코드와 상태 메세지는 100번대부터 500번대까지 존재한다.

- 1xx(조건부 응답): 요청을 받았으며 작업을 계속한다는 코드
- 2xx(성공): 정상적으로 요청을 수행했을 때 나타나는 코드
- 3xx(리다이렉션 완료): 클라이언트가 요청을 마치기 위해 추가 동작을 취해야 할 때 나타나는 코드
- 4xx(요청 오류): 클라이언트의 요청에 오류가 있을 때 나타나는 코드
- 5xx(서버 오류): 서버가 들어온 요청을 수행하지 못했을 때 나타나는 코드

#### 헤더(Headers)
요청 헤더와 유사한 형식으로 추가 정보를 전달한다. 위 예시에 나온 헤더들을 한 번 더 설명하면 다음과 같다.

- content-type
  - 전달한 리소스의 타입
  - text/html이라면 텍스트 중에서도 HTML 타입이라는 의미
  - image/jpeg라면 jpeg 확장자를 가진 이미지라는 의미
- content-encoding
  - 응답 메세지 헤더의 accept-encoding처럼 컨텐츠가 압축된 방식을 표시
- date
  - 해당 메세지가 만들어진 날짜와 시간을 포함

#### 본문(Body)
가져온 리소스가 표시된다. 만약 리소스 유형이 HTML이라면, `<html><body></body></html>` 형태의 HTML코드가 나타나고, 
유형이 이미지 또는 동영상이면 그에 맞는 코드가 표시된다.

## 3. 프록시 서버
프록시 서버는 **웹 클라이언트**와 **웹 서버** 사이에서 데이터를 전달해준다.

### 프록시(Proxy)
프록시는 "대리인"이라는 사전적 의미를 지니며 **클라이언트와 서버 사이에 HTTP 메세지를 대신 전달하는 중계 기능**을 말한다.
그리고 이러한 프록시 기능을 수행하는 서버를 가리켜 **프록시 서버**라고 부른다.
지금은 IP주소를 우회하기 위한 용도로 쓰이고 있지만 90년대 후반까지만 해도 빠른 인터넷 속도 향상을 목적으로 사용되었다.

### 특징
- 클라이언트와 서버가 주고받은 적이 있는 데이터의 사본이 저장되어 있다.
- 이전과 동일한 데이터를 요청하는 경우 서버를 거치고 않고 바로 프록시에서 **캐싱해 둔 데이터를 반환하여 전송 시간을 줄일 수 있다**는 장점이 있다.
- 메세지가 지나갈 때마다 Via 헤더에 정보를 추가해야 하는데 프록시 서버 또한 Via 헤더에 기록되므로 나중에 **메세지 접근을 제어하거나 추적** 하는데 사용 가능
- IP, 쿠키 등 HTTP 메세지에 신원을 확인할 수 있는 정보들을 제거함으로써 **익명셩을 보호**할 수 있다.

### 유형
1. 포워드 프록시(Forward Proxy)
- 서버의 메세지를 클라이언트에게 전달하는 역할을 수행
2. 리버스 프록시(Reverse Proxy)
- 클라이언트의 요청을 다수 서버에 분배하여 전달하는 역할을 수행
- 서버가 여러 개일때, 클라이언트의 요청을 어느 서버에 전달하면 좋을 지 확인하고 서버를 선택하는 것

하나의 프록시 서버는 위의 2가지 기능을 모두 수행할 수 있다.

### Via 헤더
Via는 해당 HTTP 메세지가 거쳐온 프록시 또는 게이트웨이의 정보를 담고 있다.

```
[<프로토콜 이름> /]<프로토콜 버전> <호스트>[:<포트>]
[<프로토콜 이름> /]<프로토콜 버전> <내부 프록시의 이름 or 별칭>
```

위와 같은 포맷을 가지며 `[]` 내 항목은 생략할 수 있다.

이를 통해 메세지가 1개 이상의 프록시, 게이트웨이를 지나갈 경우 반드시 Via 목록 끝에 정보가 추가되어야 한다.
그리고 나열된 목록을 통해 클라이언트와 서버 사이에 어떤 중계기가 있었는지 추적할 수 있다.

## 4. DNS

### 고유한 주소, IP
**인터넷 장치 각각을 식별할 수 있는 고유한 주소**를 `IP(Internet Protocol)` 이라고 한다.
이에 관한 자세한건 [net practice](https://github.com/Kdelphinus/42born2code/tree/main/net_practice) 부분을 참고할 것

### 외우기 쉬운 주소, 도메인
도메인은 외우기 힘든 IP 대신 **사람이 기억하기 쉽게 만든 인터넷 주소**를 말한다.

#### 도메인의 구성 요소
점을 기준으로 가장 오른쪽에 있는 도메인이 최상위이며 왼쪽으로 갈수록 하위 도메인이다.
그리고 최상위 도메인은 kr, us 등 나라를 나타내는 **국가 도메인**과 기타 com, net과 같은 **일반 도메인**으로 나뉜다.

참고로 최상위 도메인 뒤에 이런저런 경로가 붙는 것까지 포함해서 `URL` 이라고 한다.

### DNS
`DNS(Domain Name System)`는 **도메인 주소를 IP 주소로 변환해주는 역할을 하는 시스템**이다.
그리고 이런 변환 시스템을 운영하고 있는 서버를 **DNS 서버 또는 네임서버**라고 한다.

![dns](/img/dns.png)

먼저 일반 사용자, 즉 호스트는 **원하는 도메인을 브라우저에 입력**한다. 우리의 컴퓨터는 보통 DNS 서버의 IP를 기억하고 있는데,
그렇기에 입력받은 뒤 DNS 서버의 IP로 아까 받았던 도메인 주소를 전달한다.

DNS 서버는 **평소에는 수많은 도메인 이름들을 기억**하고 있다가, 어떤 호스트에게서 요청이 들어오면 **받은 도메인이 가리키고 있는 IP 주소를 찾아서 반환**한다.

## 5. IP
대부분의 내용은 [net_practice](https://github.com/Kdelphinus/42born2code/tree/main/net_practice)에 있다.

### 사설 IP로 통신하는 과정
사설 IP 주소의 경우, **다른 컴퓨터와 주소가 동일한 경우**를 자주 볼 수 있다.
그 이유는 사설 IP 주소가 하나의 라우터 안에서만 겹치지 않게 할당받은 주소이기 때문이다.

그렇다면 어떻게 중복되는 사설 IP 주소를 가지고 다른 컴퓨터와 통신을 주고 받을 수 있는가?
먼저 요청을 보내는 호스트의 IP는 **사설 IP 주소**로 되어있다.
그러나 라우터를 거치면서 자동으로 공인 IP 주소를 변경하여 전송하는데 이 과정을 `NAT(Network Address Translation)` 이라고 하며 라우터에 탑재된 기능이다 .

동작되는 과정은 다음과 같다.

1. 개인 PC에서 요청을 보낸다.
2. 라우터에 메세지가 도착하고, 라우터는 NAT 기능을 이용해 호스트 주소를 공인 IP로 변경하여 서버에 전달한다.
3. 서버는 메세지에 응답하고 데이터를 라우터에 전달한다.
4. 라우터는 처음 요청했던 개인 PC로 데이터를 보낸다.

## 6. 그림으로 쉽게 보는 TCP
TCP는 네트워크에서 IP와 함께 원활한 인터넷 통신을 위해 만든 프로토콜이다.

### 왜 필요할까
먼저 인터넷에서 어떻게 데이터를 주고받는지 알아봐야 한다.

현재 우리는 데이터를 `패킷(Packet)` 이라는 작은 조각으로 쪼갠 뒤 주고받고 있다.
패킷으로 쪼개는 이유는 만약 무거운 데이터를 통으로 보내다가 회선에 문제가 생길 때 다시 전송하기 위해 많은 리소스를 낭비할 수 있기 떄문이다.

이를 방지하기 위해 컴퓨터는 패킷을 쪼갠 뒤 빠르다고 생각되는 회선으로 각각 전달한다.
이렇게 패킷 단위로 전송하게 되면 각 패킷은 **다양한 경로를 사용하여 이동**할 수 있고 또 중간에 **회선 하나가 끊겨도 다른 패킷들이 안정적으로 들어올 수 있다**는 장점이 있다.

다만 문제는 조각난 패킷들이 **전부, 그것도 순서대로 잘 들어왔는지 확인하기 힘들다**는 점이다.
IP 또한 정확한 주소로 보내는 것에만 집중할 뿐, 데이터가 정상적으로 들어왔는지 고려하지 못한다.
이 문제를 해결하기 위해 생긴 프로토콜이 `TCP(Transmission Control Protocol)` 이다.

### TCP 그리고 IP
**TCP와 IP**의 관계는 **택배 기사와 내비게이션**의 관계와 유사하다. 

IP는 적힌 IP 주소와 일치하는 장소로 보내는데만 집중한다. 하지만 TCP는 목적지에 데이터가 안정적으로 도착하는데 집중한다.
또 TCP는 안전하게 데이터를 전달하기 위해 수신자가 데이터를 받을 수 있는 상황인지도 고려한다.
이렇게 TCP는 서로 연결된 상태인지 주기적으로 확인한다고 해서 **연결형**, IP는 **비연결형**이라고 한다.

![tcp](/img/tcp.png)

- 보내는 쪽
  1. 데이터에 대한 요청이 들어온다.
  2. TCP에서는 데이터를 적당한 크기의 패킷으로 자른 뒤 IP에 전달한다.
  3. IP는 패킷을 받아서 주소를 해석하고 경로를 결정하여 목적지로 전송한다.
- 받는 쪽
  1. IP는 도착한 패킷의 주소가 내 주소와 맞는지 확인한다.
  2. 맞다면 받는 쪽 컴퓨터의 TCP로 전달한다.
  3. TCP는 패킷들을 모아 데이터를 재조립한다.
  4. 이 과정에서 손상되거나 빠진 패킷이 있다면 재전송을 요청한다.

이처럼 IP와 TCP는 정확한 데이터 전송을 위해 긴밀하게 연결되어 있다.
그래서 일반적으로 인터넷 데이터 통신을 위한 프로토콜을 한데 묶어 `TCP/IP` 라고 부르기도 한다.

### 3 way handshake 로 더 정확하게
앞서 말했듯이 TCP는 수신자가 데이터를 받을 수 있는 상태인지 확인한다.
이때 사용하는 TCP의 중요한 기법 중 하나가 `3 way handshake`이다.

과정은 다음과 같다.

1. 보내는 쪽(클라이언트)에서 받는 쪽(서버)에게 통신을 하고 싶다는 메세지를 보낸다.
2. 받는 쪽은 메세지에 대한 답장과 현재 통신 준비가 완료되었다는 메세지를 보낸다.
3. 보내는 쪽이 받는 쪽에다가 통신 준비가 완료되었다는 메세지를 보낸다.
4. 통신이 시작된다.

### TCP의 단점, 그리고 UDP
TCP는 데이터를 전송하기 위해 확인할 게 많다보니 **전송 속도가 느리다**는 단점이 있다.
글, 사진 등의 데이터라면 큰 문제가 되진 않지만 목소리, 영상 등 실시간성이 중요한 데이터의 경우 사용자가 한 번 로딩하는데 오랜 시간을 기다릴 수 있다.

그래서 TCP와 유사한 역할을 수행하지만 속도는 빠른 `UDP(User Datagram Protocol)` 라는 프로토콜이 생겼다.
UDP는 TCP와 다르게 일방적으로 데이터를 전송하는 방식이다.

![udp](/img/udp.png)

그래서 TCP보다 용량이 적고 속도가 빠른 장점이 있지만 데이터의 신뢰성이 없기 때문에 데이터가 유실되거나 순서가 바뀔 위험성이 있다.
이런 장단때문에 UDP는 속도가 중요하고 데이터가 일부 유실되어도 서비스 이용에 큰 문제가 없는 **온라인 게임**이나 **VoIP**라고 부르는 음성 데이터를 주고받을 때 사용한다.


## 7. 그림으로 쉽게 보는 HTTP 변천사
### 초기 HTTP, HTTP/0.9
**WWW(World Wide Web)이 만들어지면서 함께 등장한 HTTP**는 정말 통신에 필요한 최소한의 기능만 갖고 있다.
어떤 데이터를 요청한다는 본문을 보내면 요청한 메세지에 대한 결과를 본문에 담아 응답했다.

HTTP/0.9(이는 1.0버전이 나온 후, 차이를 두기 위해 나중에 붙여진 이름)는 에러가 발생했을 경우, 응답 메세지의 본문에 에러를 적어 보냈다.
이렇게 처음에는 **실제 데이터의 전송만을 위해** 사용되었다. 
HTTP는 웹의 발전과 더불어 다양한 기능이 추가되었으나 제대로 정리되지 않아 다양한 프로토콜들이 마구잡이로 만들어졌다.
이를 하나로 정리하고자 문서화 한 것이 **HTTP/1.0**이다.

### 각 잡고 문서화, HTTP/1.0
HTTP/1.0부터 우리가 익히 아는 형태가 나온다. 
이 때 등장한 대표적인 것 중 하나가 **헤더**이다. 해당 메세지의 정보를 담고 있는 역할로 이를 통해 메세지의 개괄적인 의미를 파악할 수 있다.

그러나 1.0은 **분산된 기능만 하나로 정리했을 뿐, 공식 표준이 아니었다.**

### 진짜 표준, HTTP/1.1
HTTP/1.0이 나온 지 몇 달 지나지 않아 HTTP/1.1이 공개되었다.
큰 맥락은 HTTP/1.0과 동일하지만 모호한 기능들을 개선하며 진정한 표준이 되었다.

당시 HTTP/1.0은 모든 요청마다 새로운 연결을 맺어야 했다. 
요청하는 컴퓨터와 응답하는 컴퓨터가 데이터를 통신하기 위해 연결을 하고 요청과 응답을 한 번씩 주고받고 나면 연결을 끊고 다시 새 연결을 하는 방식이었다.
여기서 문제는 **동일한 컴퓨터 사이에서 여러 개의 컨텐츠를 요청할 때에도 매 번 새 연결을 맺어야 한다는 것**이다. 
특히 TCP에선 한 번 연결할 때마다 3 way handshake가 이루어졌는데 이는 한 번의 동작만으로도 시간을 꽤나 잡아먹었다.
이를 몇 번이나 반복하니 속도가 눈에 띄게 느려진 것이다. 초창기 웹에선 이용하는 컨텐츠가 적다 보니 큰 문제가 되지 않았지만 점차 웹이 고도화되자 불편함은 늘어갔다.

그래서 이러한 문제점을 해결하기 위해 탄생한 HTTP/1.1에서는 아래와 같은 방법을 통해 효과적으로 통신 속도를 개선한다.

![HTTP/1.1](/img/http11.png)

우선 각 요청마다 TCP 연결을 반복했던 HTTP/1.0과 달리 HTTP/1.1에서는 **한 번 TCP 연결을 맺으면 끊지 않고 계속 유지(persist connection)**할 수 있게 된다.
반복되는 3 way handshake를 단 한 번으로 줄여 메모리 자원을 절약하고 성능을 개선할 수 있게 되었다.
거기에다가 응답이 돌아오기를 기다리지 않고 **한 번에 여러 개의 요청을 보낼 수 있게(Pipelining)**해 통신 속도를 더욱 높였다.

이렇게 표준화된 HTTP는 15년이 넘도록 자잘한 기능을 확장하며 1.1버전을 유지했다.

이러다가 어느 날, 2009년에 Google에서 `SPDY(스피디)`라는 새 프로토콜을 발표한다.

![spdy](/img/spdy.png)

speedy라는 단어를 기반으로 만들어진 이 기술은 HTTP/1.1 성능제한을 해결하고 웹 페이지의 **로드 지연 시간을 줄이기 위해** 만들어졌다.
그리고 이를 본 HTTP 관계자는 SPDY를 기반으로 새 HTTP 버전을 만들어보자 제안했고 제안이 성사되어 2015년 5월에 **SPDY를 기반으로 HTTP/1.1의 단점을 개선한 `HTTP/2`**가 나오게 된다.

### 더 빠르게, HTTP/2
HTTP/2가 HTTP/1.1과 다른 점을 요약하자면 **성능, 속도 개선**이다. 이쯤 되면 알 수 있겠지만 모든 새 HTTP 버전의 주된 목적은 속도이다.

![HTTP/2](/img/http2.png)

HTTP/1.1은 서로 간의 연결은 유지되어도 그 안에서 아직도 하나의 요청은 하나의 응답이라는 **1:1 대응**을 이루고 있었다.
거기에 더불어 요청이 순서대로 처리되다 보니, 앞의 요청 시간이 길어질 경우 뒤에 있는 요청들도 덩달아 지연되는 문제가 있었다.
이러한 문제들을 해결하기 위해 HTTP/2에선 요청에 대한 응답을 대기하지 않고도 뒤의 응답을 받을 수 있도록 **모든 요청과 응답을 병렬적으로 처리**했다.

더불어 한 번의 요청만으로도 여러 개의 응답을 받을 수 있고(Multiplexed Streams), 클라이언트가 요청하지 않아도 서버에서 미리 필요한 리소스들을 푸시하는(Server Push) 등 더 높은 성능과 빠른 속도를 보장할 수 있게 되었다.

이렇게 HTTP/2가 변화를 가져올 수 있었던 이유는 `바이너리 프레이밍(binary framing)` 때문이다.

![binary framing](/img/binary_framing.png)

바이너리 프레이밍이란 HTTP/2의 핵심으로 우리가 읽을 수 있는 텍스트 형식이었던 HTTP 메세지를 더 작은 단위로 쪼개 **바이너리 형태로 캡슐화**한 것을 뜻한다.
같은 메세지라도 더 작게 전달할 수 있게 된 것이다.

### 따끈한 새 버전, HTTP/3
이러다 2020년에 HTTP/3이 발표된다. 좋아보이던 HTTP/2에도 고질적인 문제가 있었는데 바로 여전히 **오래된 프로토콜인 TCP** 위에서 동작하고 있다는 것이다.
이 부분에 대해선 모든 관계자가 고민하고 있었고 이를 극복할 새로운 프로토콜인 `QUIC` 가 만들어진다.

![QUIC](/img/quic.png)

2013년에 발표한 QUIC는 **Quick `UDP` Internet Connection**의 약자로 UDP 위에서 작동하는 것이 특징이다.
QUIC는 UDP의 단점인 데이터의 신뢰성 문제를 중간에 데이터 손실이 발생해도 이를 개별적으로 재전송할 수 있게 함으로써 극복하였다.

![udp + quic](/img/udp_quic.png)

이러한 **QUIC을 사용한 차세대 프로토콜**을 `HTTP/3`이라고 부른다. 
아직 HTTP/3은 표준이 아니며 현재 draft 상태이지만, Google이나 Facebook을 비롯해 2022년 1월 기준 전체 웹사이트의 24.5%가 사용하고 있는 등 여러 서비스에서 시범적으로 사용하고 있다.

## 8. 웹 1.0부터 3.0까지, 가볍게 읽는 웹 변천사

### 웹의 탄생과 1.0
**웹이 탄생한 1990년부터 웹 2.0이 유행하기 전인 약 2004년까지의 구간**을 웹 1.0이라고 부른다.

웹 1.0시대에서 대부분의 유저는 정보를 단순히 소비하기만 했다. 
이 당시는 정보 공급자와 소비자의 역할이 엄격하게 구분되었기에 `읽기 전용(Read Only)`의 기능이 가장 컸다.

### 읽고 쓰고 웹 2.0
그러던 중, 2004년 전후로 페이스북과 유튜브 같은 플랫폼 서비스들이 등장하며 **단방향 소통이 양방향 소통으로 변화**하기 시작했다.
이렇게 **읽기(Read)에 `쓰기(Write)`의 개념을 더한 것** 이 웹 2.0이다.
에어비앤비, 틱톡 등 사용자가 생산자가 될 수 있는 구조를 가지는 서비스는 모두 웹 2.0이다.

하지만 우리가 유튜브에 영상을 올린다고 해도 그것이 온전히 우리 소유는 아니다.
왜냐하면 그 영상은 결국 유튜브 서버실 안에 있고 서버의 보안 문제가 생기거나 서비스 자체가 종료되면 사라지기 때문이다.

이처럼 웹 1.0과 웹 2.0에 등장한 서비스들은 그 안에서 탄생한 모든 데이터를 중앙화 된 서버에서 관리하고 있다.
그리고 이는 **서비스에서 발생하는 데이터는 모두 기업이 소유하며 이를 활용한 이익 역시 기업이 독점한다는 문제점**이 있다.

### 온전히 내 것으로, 웹 3.0
웹 3.0은 2000년대부터 차세대 웹을 가리키는 용어로 꾸준히 거론되었다.
그리고 초기의 웹 3.0은 주로 **시맨틱 웹(Semantic Web)**을 의미했다.
시맨틱 웹이란 웹 창시자인 팀 버너스리가 1998년 처음 제안한 것으로 컴퓨터가 단어, 문장의 뜻을 이해하고 논리적인 추론을 하는 웹 기술을 가리킨다.

하지만 2020년대에 큰 이슈가 되었던 웹 3.0은 이러한 시맨틱 웹에서 더 나아가 데이터의 분산화, 즉 **탈중앙화**에 초점을 맞춘다.
여기서 탈중앙화는 웹 서비스를 이용하는 과정에서 생성된 데이터와 그로 인해 파생된 재정적 보상을 개인이 온전히 소유해 데이터에 대한 통제권을 일반 사용자들이 가져오는 형태를 의미한다.

그리고 이를 가능케 하는 기술이 **블록체인**이다. 블록체인은 간단하게 데이터를 기록한 장부를 데이터를 만드는데 참여한 사람들에게 나누어주는 기술로,
데이터를 만드는 데 기여한 사람들끼리 정보를 나눠 갖는 구조다. 마치 열쇠를 부분적으로 잘라 나눠 갖는 것이다.
따라서 현재 웹 3.0 사례라고 불리는 서비스들은 블록체인 기술을 사용한 경우가 대부분이다.

더불어 **NFT** 또한 블록체인 기술을 활용한 것이다.
NFT란 대체 불가능한 토큰을 의미하며 디지털 자산의 소유권을 인증하는 일종의 인증서 역할을 한다.
콘텐츠가 아무리 복사되어도 소유권은 한 명만 가지고 있는 것이다.

다만 웹 3.0은 정의가 명확하지 않기에 토론도 활발히 이어지는 중이다.
가령 일론 머스크는 "웹 3.0은 실체가 없는 마케팅 용어"라고 지적한 것처럼 웹 3.0은 아직 실현되지 않았으며 블록체인이나 NFT 등을 이용해 서비스를 시작한 기업의 가치를 높이기 위한 수단이라는 비판이 있다.

## 9. 그림으로 쉽게 보는 IP 주소
net practice 문서 참고

## 10. 그림으로 쉽게 보는 HTTPS, SSL, TLS

### 보안을 책임지는 HTTPS
`HTTPS(Hypertext Transfer Protocol Secure)`는 **HTTP에서 보안이 강화된 프로토콜**이다.
누구나 볼 수 있던 메세지를 통신하는 당사자들만 볼 수 있도록 암호화해 HTTP의 보안 문제를 해결했다는 점이 가장 큰 특징이다.
또한 특정 서비스가 HTTPS를 사용하고 있는지 **브라우저 상단의 주소창**을 통해 쉽게 파악할 수 있다.
웹을 이용할 때, URL이 https:// 로 시작하고 앞에 자물쇠가 달린 것을 종종 볼 수 있는데 이를 통해 해상 사이트가 https 프로토콜을 사용하고 있음을 알 수 있다.

요즘은 대부분의 페이지가 HTTPS를 사용하고 있으며 크롬 등의 브라우저에서는 HTTP 페이지에 접근하면 '주의 요함'이라는 보안 경고를 표시하는 등 안전한 웹 서비스 사용을 위해 주의를 기울이고 있다.

### SSL과 TLS는 무엇이 다를까
하지만 HTTP의 보안은 사실 HTTPS가 아닌 다른 곳에서 담당하고 있다. 바로 `SSL(Secure Sockets Layer)` 이다.
SSL은 **클라이언트와 서버가 서로 데이터를 암호화해 통신할 수 있도록 돕는 보안 계층**이다.
HTTPS가 데이터를 안전하게 주고 받을 수 있는 이유가 바로 SSL를 사용하기 때문이다.

![https](/img/https.png)

OSI 계층으로 보면 HTTP 아래 SSL 계층이 추가되었다. 
또한 OSI 계층은 서로 독립되어 있기에 HTTPS뿐만 아니라 파일 전송을 위한 FTP, 이메일 전송에 사용되는 SMPT처럼 HTTP와 같은 계층의 프로토콜과 말이다.
그리고 `TLS(Transport Layer Security)` 역시 약간의 차이는 있지만 같은 보안 프로토콜에서 시작됐다.

원인은 SSL이 갓 알려지기 시작한 1990년대 후반에 당시 공개된 SSL 2.0에 취약점을 해결하기 위해 아예 구조를 재설계해 SSL 3.0을 배포했다.
그 후, 기존 버전과 구분하기 위해 3.0 다음부터 등장한 SSL의 이름을 TLS로 변경했다.
하지만 사람들이 SSL이란 이름이 익숙해 더 이상 SSL을 사용하고 있지 않은 현재에도 계속 SSL이라고 부르고 있는 것이다.

### 대칭키, 공개키로 안전하게 암호화하기
SSL은 **공개키 기법**과 **대칭키 기법**이라는 두 암호화 기법을 함께 사용하고 있다.

![key](/img/key.png)

`대칭키 기법`은 **하나의 키로 암호화와 복호화를 둘 다 할 수 있는 암호화 기법**이다.
즉, 클라이언트와 서버가 같은 키를 가지고 있다가 데이터가 왔을 때 그 키로 복호화와 암호화를 하는 것이다.
대칭키 기법은 암호화, 복호화 속도가 빠르지만 키를 안전하게 교환하기 어렵다는 단점이 있다.

![key2](/img/key2.png)

이를 보완하기 위한 방식이 `공개키 기법`이다. 공개키 기법은 **서로 다른 키 두 개로 암호화, 복호화를 한다는 특징**이다.
이때 사용하는 키 두 개를 각각 **공개키, 개인키**라고 부른다. 공개키는 누구나 가질 수 있는 키지만 개인키는 소유자 한 명만 가질 수 있는 키로 이 두 키는 늘 한 쌍으로 동작한다.

보물상자에 비유하면 공개키는 **각기 다른 형태인 열쇠 두 개가 한 쌍으로 이루어져 있다는 점**이다. 
보물상자를 만약 빨간 키로 잠갔다면 파란 키로만 열 수 있다. 반대로 파란 키로 잠갔다면 빨간 키로만 열 수 있다.

이와 마찬가지로 **공개키로 암호화한 데이터는 개인키로만 복호화할 수 있고, 개인키로 암호화한 데이터는 공개키로만 복호화할 수 있다.**

- 대칭키
  - 암호화, 복호화 속도가 빠름
  - 키를 안전하게 교환하기 어렵다.
- 공개키
  - 암호화, 복호화 속도가 상대적으로 느림
  - 키를 안전하게 교환할 수 있음

SSL은 두 기법을 함께 사용하여 서로의 단점을 보완하고 있다.

### SSL 동작 과정
SSL은 크게 **핸드 셰이크, 세션, 세션 종료 세 단계**로 이루어진다.
핸드 셰이크는 TCP의 3방향 핸드 셰이크와 유사하게 클라이언트와 서버가 통신할 준비가 되었는지 확인하는 과정이다.

![ssl handshake](/img/ssl_handshake.png)

1. Client Hello
- 클라이언트가 서버에게 인사
- **랜덤한 데이터와 현재 지원할 수 있는 암호화 방식을 서버에게 전달**

2. Server Hello
- 클라이언트에게 인사를 받은 서버가 클라이언트에게 인사를 보냄
- 서버는 클라이언트에게 세 가지 내용을 전달
  - **클라이언트가 전달한 내용과 동일한 랜덤 데이터**
  - **지원 가능한 암호화 방식**
  - **인증서**
- 이때 인증서는 서버가 공식으로 인증된 기관인 CA(Certificate Authority)에서 발급받은 문서로 서버가 신뢰할 수 있는지 보장하는 역할

3. 서버 인증서 확인, 임시 대칭키 생성
- 인증서를 검증하기 위해 **CA가 발급한 인증서 목록 중에 서버가 전달한 인증서가 있는지 확인**
- 인증서 목록에 있다면 CA에서 공유하는 공개키를 가지고 **인증서를 복호화**
- 만약 복호화가 성공한다면 이 인증서는 서버가 자신의 비밀키로 암호화를 했다는 것이 검증되는 것

4. 임시 대칭키 전달
- 본격적으로 키를 주고받기 위해 클라이언트는 실제 데이터 통신에서 사용할 **대칭키를 임시로 만든다.**
- 이 임시 키(pre master secret)는 클라이언트와 서버가 주고받은 랜덤한 데이터를 조합해 만든다.
- 임시 키는 대칭키이기에 절대 제 3자에게 노출되면 안되므로 가지고 있던 공개키로 암호화해서 서버에게 전달

5. 비밀키로 복호화
- 키를 받은 서버는 자신이 갖고 있던 비밀키로 암호를 해독하여 **임시 키를 전달받음**
- 이렇게 서버와 클라이언트는 같은 키를 갖는다.

6. 세션키 생성
- 클라이언트와 서버는 일련의 과정을 거쳐 임시 키를 **세션 키**로 바꾼다.
- 그리고 세션 키를 이용해 클라이언트와 서버가 통신하게 된다.

그 후, 세션 단계에서는 앞서 생성한 세션 키를 이용해 대칭키 기법으로 데이터를 암호화하여 전달한다.
그리고 데이터 전송이 끝나면 세션을 종료해 통신을 마친다.


## 11. 그림으로 쉽게 보는 이더넷
나중에 [그림으로 쉽게 보는 이더넷](https://brunch.co.kr/@swimjiy/49) 정리하기
